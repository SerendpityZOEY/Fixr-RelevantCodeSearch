/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactServerMultiChild
 * @typechecks static-only
 */

'use strict';

var ReactCurrentOwner = require('react-universal/lib/ReactCurrentOwner');
var ReactServerChildReconciler = require('./ReactServerChildReconciler');

/**
 * ReactMultiChild are capable of reconciling multiple children.
 *
 * @class ReactMultiChild
 * @internal
 */
var ReactMultiChild = {

  /**
   * Provides common functionality for components that must reconcile multiple
   * children. This is used by `ReactDOMComponent` to mount, update, and
   * unmount child components.
   *
   * @lends {ReactMultiChild.prototype}
   */
  Mixin: {

    _reconcilerInstantiateChildren: function _reconcilerInstantiateChildren(nestedChildren, transaction, context) {
      if (__DEV__) {
        if (this._currentElement) {
          try {
            ReactCurrentOwner.current = this._currentElement._owner;
            return ReactServerChildReconciler.instantiateChildren(nestedChildren, transaction, context);
          } finally {
            ReactCurrentOwner.current = null;
          }
        }
      }
      return ReactServerChildReconciler.instantiateChildren(nestedChildren, transaction, context);
    },

    /**
     * Generates a "mount image" for each of the supplied children. In the case
     * of `ReactDOMComponent`, a mount image is a string of markup.
     *
     * @param {?object} nestedChildren Nested child maps.
     * @return {array} An array of mounted representations.
     * @internal
     */
    mountChildrenAsync: function mountChildrenAsync(nestedChildren, transaction, context, writeFn, cache, callback) {
      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
      var names = [];
      for (var name in children) {
        names.push(name);
      }
      if (names.length > 0) {
        this.renderChildren(0, names, children, transaction, context, writeFn, cache, callback);
      } else {
        callback();
      }
    },

    renderChildren: function renderChildren(index, names, children, transaction, context, writeFn, cache, callback) {
      var _this = this;

      var name = names[index];
      var child = children[name];
      var rootID = this._rootNodeID + name;
      // this is necessary to avoid stack overflows.
      var finishFn = (index + 1) % 5000 === 0 ? function () {
        return process.nextTick(callback);
      } : callback;
      child.mountComponentAsync(rootID, transaction, context, writeFn, cache, function () {
        if (index + 1 < names.length) {
          _this.renderChildren(index + 1, names, children, transaction, context, writeFn, cache, finishFn);
        } else {
          finishFn();
        }
      });
    }
  }

};

module.exports = ReactMultiChild;