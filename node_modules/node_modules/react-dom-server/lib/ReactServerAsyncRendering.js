/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks static-only
 * @providesModule ReactServerAsyncRendering
 */
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ReactElement = require('react-universal/lib/ReactElement');
var ReactServerRenderingTransaction = require('./ReactServerRenderingTransaction');
var instantiateReactServerComponent = require('./instantiateReactServerComponent');

var stream = require("stream");
var invariant = require('fbjs/lib/invariant');
var emptyObject = require('fbjs/lib/emptyObject');
var isReadableStream = require('./isReadableStream');
var rollingAdler32 = require('./rollingAdler32');

// this is a pass through stream that can calculate the hash that is used to
// checksum react server-rendered elements.

var ChecksumStream = (function (_stream$Transform) {
  _inherits(ChecksumStream, _stream$Transform);

  function ChecksumStream(rootId, options) {
    var _this = this;

    _classCallCheck(this, ChecksumStream);

    _get(Object.getPrototypeOf(ChecksumStream.prototype), 'constructor', this).call(this, options);
    this.rootId = rootId;
    this.rollingHash = rollingAdler32("");
    this.on("end", function () {
      _this.done = true;
    });
  }

  _createClass(ChecksumStream, [{
    key: '_transform',
    value: function _transform(chunk, encoding, next) {
      this.rollingHash = rollingAdler32(chunk.toString("utf-8"), this.rollingHash);
      this.push(chunk);
      next();
    }
  }, {
    key: '_flush',
    value: function _flush(next) {
      var hash = this.rollingHash.hash();
      var scriptId = this.rootId + '.script';
      this.push('<script type="text/javascript" id="' + scriptId + '">\n        if (!document.querySelector) throw new Error("react-dom-stream requires document.querySelector. If using IE8 or IE9, please make sure you are in standards mode by including <!DOCTYPE html>");\n        document.querySelector(\'[data-reactid="' + this.rootId + '"]\').setAttribute("data-react-checksum", ' + hash + ');\n        var s = document.getElementById("' + scriptId + '");\n        s.parentElement.removeChild(s);\n      </script>');
      next();
    }
  }]);

  return ChecksumStream;
})(stream.Transform);

var RenderStream = (function (_stream$Readable) {
  _inherits(RenderStream, _stream$Readable);

  function RenderStream(componentInstance, id, transaction, context, cache, options, maxStackDepth) {
    _classCallCheck(this, RenderStream);

    _get(Object.getPrototypeOf(RenderStream.prototype), 'constructor', this).call(this, options);
    this.buffer = "";
    this.componentInstance = componentInstance;
    this.id = id;
    this.transaction = transaction;
    this.context = context;
    this.cache = cache;
    this.maxStackDepth = maxStackDepth || 500;
    this.nextTickCalls = 0;
  }

  /**
   * @param {ReactElement} element
   * @return {string} the HTML markup
   */

  _createClass(RenderStream, [{
    key: '_read',
    value: function _read(n) {
      var _this2 = this;

      var bufferToPush;
      if (this.done) {
        this.push(null);
        return;
      }
      // it's possible that the last chunk added bumped the buffer up to > 2 * n, which means we will
      // need to go through multiple read calls to drain it down to < n.
      if (this.buffer.length >= n) {
        bufferToPush = this.buffer.substring(0, n);
        this.buffer = this.buffer.substring(n);
        this.push(bufferToPush);
        return;
      }

      if (this.stream) {
        var data = this.stream.read(n);
        // if the underlying stream isn't ready, it returns null, so we push a blank string to
        // get it to work.
        if (null === data) {
          this.push("");
        } else {
          this.push(data);
        }
        return;
      }
      // if we have are already rendering and have a continuation to call, do so.
      if (this.continuation) {
        // continue with the rendering.
        this.continuation();
        return;
      }

      this.stackDepth = 0;
      // start the rendering chain.
      this.componentInstance.mountComponentAsync(this.id, this.transaction, this.context, function (text, cb) {
        if (isReadableStream(text)) {
          var _ret = (function () {
            // this is a stream
            _this2.stream = text;
            _this2.stream.on("end", function () {
              _this2.stream = null;
              cb();
            });
            var data = _this2.stream.read(n - _this2.buffer.length);

            setImmediate(function () {
              if (data === null) data = _this2.stream.read(n - _this2.buffer.length);
              _this2.push(_this2.buffer + (data === null ? "" : data));
              _this2.buffer = "";
            });
            return {
              v: undefined
            };
          })();

          if (typeof _ret === 'object') return _ret.v;
        }

        _this2.buffer += text;
        if (_this2.buffer.length >= n) {
          _this2.continuation = cb;
          bufferToPush = _this2.buffer.substring(0, n);
          _this2.buffer = _this2.buffer.substring(n);
          _this2.push(bufferToPush);
        } else {
          // continue rendering until we have enough text to call this.push().
          // sometimes do this as process.nextTick to get out of stack overflows.
          if (_this2.stackDepth >= _this2.maxStackDepth) {
            process.nextTick(cb);
          } else {
            _this2.stackDepth++;
            cb();
            _this2.stackDepth--;
          }
        }
      }, this.cache, function () {
        // the rendering is finished; we should push out the last of the buffer.
        _this2.done = true;
        _this2.push(_this2.buffer);
      });
    }
  }]);

  return RenderStream;
})(stream.Readable);

function renderToStringImpl(element) {
  var makeStaticMarkup = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

  var _ref = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  var cache = _ref.cache;
  var rootID = _ref.rootID;

  var transaction = ReactServerRenderingTransaction.getPooled(false);
  rootID = rootID || '.0';

  var readable = transaction.perform(function () {
    var componentInstance = instantiateReactServerComponent(element, null);
    return new RenderStream(componentInstance, rootID, transaction, emptyObject, cache);
  }, null);

  readable.on("end", function () {
    ReactServerRenderingTransaction.release(transaction);
  });

  if (!makeStaticMarkup) {
    readable = readable.pipe(new ChecksumStream(rootID));
  }

  return readable;
}

function createRenderToStringStream(element, options) {
  return renderToStringImpl(element, false, options);
}

function createRenderToStaticMarkupStream(element, options) {
  return renderToStringImpl(element, true, options);
}

module.exports = {
  createRenderToStringStream: createRenderToStringStream,
  createRenderToStaticMarkupStream: createRenderToStaticMarkupStream
};